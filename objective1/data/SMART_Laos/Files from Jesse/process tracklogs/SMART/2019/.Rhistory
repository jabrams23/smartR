for (j in 1:length(grid@polygons)) {
print(j)
#take first grid cell
tmp4 <- grid[j,]
#make new extent for lines for the day in question
ext.tmp <- extent(min(tmp@coords[,1]),
max(tmp@coords[,1]),
min(tmp@coords[,2]),
max(tmp@coords[,2]))
#check if there was any activity in the current grid cell
#inter <- intersect(ext.tmp, extent(tmp4))
inter <- gIntersects(tmp4,gI, byid=TRUE)
#if there was effort figure out the distance covered
if (any(inter==TRUE)) {
print(j)
print("TRUE!")
#crop the line to the cell of interest
cell_poly <- crop(gI, extent(tmp4))
#calculate the length of the line or "distance covered"
tmp_distance <- area(cell_poly) #lineLength(cell_poly) # THIS WORKS FINE IF I CAN GET THE SHAPEFILE CROPPED PROPERLY
#assign this to the effort shapefile
cell_size <- area(tmp4)
effort@data$length[j] <- tmp_distance
effort@data$percent_covered[j] <- tmp_distance/cell_size
#if not set effort to 0
} else {
effort@data$length[j] <- 0
effort@data$percent_covered[j] <- 0
}
effort_table[j,i] <- effort@data$percent_covered[j]
}
}
}
effort_table <- as.data.frame(effort_table)
colnames(effort_table) <- un.date
rownames(effort_table) <- seq(1,length(grid@polygons))
write.csv(effort_table,paste("effort_table_polygons_",track_name,".csv",sep=""))
} else {
write.csv(track_name,paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/error/error_",track_name,".csv",sep=""))
}
}
library(plyr)
library(readr)
library(tidyverse)
library(rqdatatable)
library(dplyr)
library(stringr)
setwd(paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,sep=""))
mypath <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/effort",sep="")
filenames <- list.files(path = mypath, full.names = TRUE)
myfiles <- lapply(filenames, read.csv)
myfiles <- rapply(myfiles,function(x) ifelse(is.na(x),0,x), how = "replace")
mydata4 <- Reduce(function(dtf1, dtf2) full_join(dtf1, dtf2,
by = intersect(names(dtf1),names(dtf2))),myfiles)
mydata4[is.na(mydata4)] <- 0
mydata5 <- aggregate(. ~ X, FUN = sum, mydata4)
rownames(mydata5) <- mydata5$X
mydata5$X <- NULL
mydata5$NA. <- NULL
mydata5 <- mydata5[ , order(names(mydata5))]
cols.nam <- colnames(mydata5)
cols.nam <- str_sub(cols.nam, 2, 11)
length(unique(cols.nam))
colnames(mydata5) <- cols.nam
write.csv(mydata5,paste("effort_",year,".csv",sep=""))
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
year <- "2017"
Sys.setenv(TZ='Asia/Ho_Chi_Minh')
Sys.timezone() ## Check. should now say 'Asia/Ho_Chi_Minh'
time.zone = "Asia/Ho_Chi_Minh" ##in case this is ever in question!
# read in paths
setwd("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART")
source("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Modified_SMART_data_processing/functions/Initial_tracklog_processing.R")
#Identify folder where tracklogs are stored.
wd.gps <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/GPX",sep="")
###########################################
# extract  spatial point data frames, one for each file, and store as a list
AllTracks <- ReadgpxTracks (wd.in = wd.gps, include.subdirs = TRUE)
##LIST AND REMOVE FROM AllTracks FILES WHICH COULDN'T BE READ.
unreadable <- names(which(sapply(AllTracks,is.null)))
AllTracks <- AllTracks[which(!names(AllTracks) %in% unreadable)]
empty <- names(which(sapply(AllTracks,function(x){nrow(x@data)==0})))
# there are no empty ones (which aren't unreadable) so next line does nothing
AllTracks <- AllTracks[which(!names(AllTracks) %in% empty)]
#grid <- readOGR("~/Dropbox (ScreenForBio)/Wilkinson_RESHARE/empty_grids","grid_500_m_saola_PAs")
grid <- readOGR("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/lucille_working_folder","grid")
grid<-spTransform(grid, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
#study_area <- st_read("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/GIS_data/HQNSLPAsnew.shp")
SA <- shapefile("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/GIS_data/HQNSLPAsnew.shp")
SA<-spTransform(SA, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
grid2 <- crop(grid,SA)
#plot(grid)
#plot(SA,add=TRUE)
plot(grid2)
plot(SA,add=TRUE)
grid <- grid2
setwd(paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/effort",sep=""))
library(doParallel)
registerDoParallel(cores=4)
#for (k in (length(AllTracks)/2):(length(AllTracks))) {
foreach(k=1:length(AllTracks)) %dopar% {
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
track_name <- names(AllTracks[k])
track_name <- substr(track_name,1,nchar(track_name)-4)
track_name <- gsub("/", "_", track_name)
track_name <- gsub("\\.", "_", track_name)
track_name <- gsub(" ", "_", track_name)
track_point <- AllTracks[[k]]
track_point <- spTransform(track_point, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
track_points <- crop(track_point,grid)
track_points$date <- track_points$time
if (!is.null(track_points)) {
track_points$date <- format(as.POSIXct(track_points$date,format='%Y/%m/%d %H:%M:%S'),format='%Y/%m/%d')
track_points$date <- as.character(track_points$date)
un.date <- unique(track_points$date)
effort <- grid
effort@data$length <- 0
effort@data$percent_covered <- 0
effort_table <- array(NA,c(length(grid@polygons),length(un.date)))
for (i in 1:length(un.date)) {
#subset to one day
tmp <- subset(track_points, (date == un.date[i]))
#order points by time
tmp2 <- tmp[order(tmp$time),]
#turn points into line
#test2 <- points_to_line(tmp2)
#points_to_line is not working...not sure why
un.coords <- unique(tmp2@coords)
if (dim(un.coords)[1] >1) {
track_lines <- coords2Lines(tmp2@coords, ID=un.date[i])
proj4string(track_lines) <- "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
b_track_lines <- gBuffer(track_lines, width=20)
#assign projection
#proj4string(track_lines) <- "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
gI <- gIntersection(grid,b_track_lines, byid=c(TRUE, TRUE))
for (j in 1:length(grid@polygons)) {
print(j)
#take first grid cell
tmp4 <- grid[j,]
#make new extent for lines for the day in question
ext.tmp <- extent(min(tmp@coords[,1]),
max(tmp@coords[,1]),
min(tmp@coords[,2]),
max(tmp@coords[,2]))
#check if there was any activity in the current grid cell
#inter <- intersect(ext.tmp, extent(tmp4))
inter <- gIntersects(tmp4,gI, byid=TRUE)
#if there was effort figure out the distance covered
if (any(inter==TRUE)) {
print(j)
print("TRUE!")
#crop the line to the cell of interest
cell_poly <- crop(gI, extent(tmp4))
#calculate the length of the line or "distance covered"
tmp_distance <- area(cell_poly) #lineLength(cell_poly) # THIS WORKS FINE IF I CAN GET THE SHAPEFILE CROPPED PROPERLY
#assign this to the effort shapefile
cell_size <- area(tmp4)
effort@data$length[j] <- tmp_distance
effort@data$percent_covered[j] <- tmp_distance/cell_size
#if not set effort to 0
} else {
effort@data$length[j] <- 0
effort@data$percent_covered[j] <- 0
}
effort_table[j,i] <- effort@data$percent_covered[j]
}
}
}
effort_table <- as.data.frame(effort_table)
colnames(effort_table) <- un.date
rownames(effort_table) <- seq(1,length(grid@polygons))
write.csv(effort_table,paste("effort_table_polygons_",track_name,".csv",sep=""))
} else {
write.csv(track_name,paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/error/error_",track_name,".csv",sep=""))
}
}
library(plyr)
library(readr)
library(tidyverse)
library(rqdatatable)
library(dplyr)
library(stringr)
setwd(paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,sep=""))
mypath <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/effort",sep="")
filenames <- list.files(path = mypath, full.names = TRUE)
myfiles <- lapply(filenames, read.csv)
myfiles <- rapply(myfiles,function(x) ifelse(is.na(x),0,x), how = "replace")
mydata4 <- Reduce(function(dtf1, dtf2) full_join(dtf1, dtf2,
by = intersect(names(dtf1),names(dtf2))),myfiles)
mydata4[is.na(mydata4)] <- 0
mydata5 <- aggregate(. ~ X, FUN = sum, mydata4)
rownames(mydata5) <- mydata5$X
mydata5$X <- NULL
mydata5$NA. <- NULL
mydata5 <- mydata5[ , order(names(mydata5))]
cols.nam <- colnames(mydata5)
cols.nam <- str_sub(cols.nam, 2, 11)
length(unique(cols.nam))
colnames(mydata5) <- cols.nam
write.csv(mydata5,paste("effort_",year,".csv",sep=""))
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
year <- "2018"
Sys.setenv(TZ='Asia/Ho_Chi_Minh')
Sys.timezone() ## Check. should now say 'Asia/Ho_Chi_Minh'
time.zone = "Asia/Ho_Chi_Minh" ##in case this is ever in question!
# read in paths
setwd("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART")
source("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Modified_SMART_data_processing/functions/Initial_tracklog_processing.R")
#Identify folder where tracklogs are stored.
wd.gps <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/GPX",sep="")
###########################################
# extract  spatial point data frames, one for each file, and store as a list
AllTracks <- ReadgpxTracks (wd.in = wd.gps, include.subdirs = TRUE)
##LIST AND REMOVE FROM AllTracks FILES WHICH COULDN'T BE READ.
unreadable <- names(which(sapply(AllTracks,is.null)))
AllTracks <- AllTracks[which(!names(AllTracks) %in% unreadable)]
empty <- names(which(sapply(AllTracks,function(x){nrow(x@data)==0})))
# there are no empty ones (which aren't unreadable) so next line does nothing
AllTracks <- AllTracks[which(!names(AllTracks) %in% empty)]
#grid <- readOGR("~/Dropbox (ScreenForBio)/Wilkinson_RESHARE/empty_grids","grid_500_m_saola_PAs")
grid <- readOGR("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/lucille_working_folder","grid")
grid<-spTransform(grid, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
#study_area <- st_read("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/GIS_data/HQNSLPAsnew.shp")
SA <- shapefile("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/GIS_data/HQNSLPAsnew.shp")
SA<-spTransform(SA, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
grid2 <- crop(grid,SA)
#plot(grid)
#plot(SA,add=TRUE)
plot(grid2)
plot(SA,add=TRUE)
grid <- grid2
setwd(paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/effort",sep=""))
library(doParallel)
registerDoParallel(cores=4)
#for (k in (length(AllTracks)/2):(length(AllTracks))) {
foreach(k=1:length(AllTracks)) %dopar% {
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
track_name <- names(AllTracks[k])
track_name <- substr(track_name,1,nchar(track_name)-4)
track_name <- gsub("/", "_", track_name)
track_name <- gsub("\\.", "_", track_name)
track_name <- gsub(" ", "_", track_name)
track_point <- AllTracks[[k]]
track_point <- spTransform(track_point, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
track_points <- crop(track_point,grid)
track_points$date <- track_points$time
if (!is.null(track_points)) {
track_points$date <- format(as.POSIXct(track_points$date,format='%Y/%m/%d %H:%M:%S'),format='%Y/%m/%d')
track_points$date <- as.character(track_points$date)
un.date <- unique(track_points$date)
effort <- grid
effort@data$length <- 0
effort@data$percent_covered <- 0
effort_table <- array(NA,c(length(grid@polygons),length(un.date)))
for (i in 1:length(un.date)) {
#subset to one day
tmp <- subset(track_points, (date == un.date[i]))
#order points by time
tmp2 <- tmp[order(tmp$time),]
#turn points into line
#test2 <- points_to_line(tmp2)
#points_to_line is not working...not sure why
un.coords <- unique(tmp2@coords)
if (dim(un.coords)[1] >1) {
track_lines <- coords2Lines(tmp2@coords, ID=un.date[i])
proj4string(track_lines) <- "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
b_track_lines <- gBuffer(track_lines, width=20)
#assign projection
#proj4string(track_lines) <- "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
gI <- gIntersection(grid,b_track_lines, byid=c(TRUE, TRUE))
for (j in 1:length(grid@polygons)) {
print(j)
#take first grid cell
tmp4 <- grid[j,]
#make new extent for lines for the day in question
ext.tmp <- extent(min(tmp@coords[,1]),
max(tmp@coords[,1]),
min(tmp@coords[,2]),
max(tmp@coords[,2]))
#check if there was any activity in the current grid cell
#inter <- intersect(ext.tmp, extent(tmp4))
inter <- gIntersects(tmp4,gI, byid=TRUE)
#if there was effort figure out the distance covered
if (any(inter==TRUE)) {
print(j)
print("TRUE!")
#crop the line to the cell of interest
cell_poly <- crop(gI, extent(tmp4))
#calculate the length of the line or "distance covered"
tmp_distance <- area(cell_poly) #lineLength(cell_poly) # THIS WORKS FINE IF I CAN GET THE SHAPEFILE CROPPED PROPERLY
#assign this to the effort shapefile
cell_size <- area(tmp4)
effort@data$length[j] <- tmp_distance
effort@data$percent_covered[j] <- tmp_distance/cell_size
#if not set effort to 0
} else {
effort@data$length[j] <- 0
effort@data$percent_covered[j] <- 0
}
effort_table[j,i] <- effort@data$percent_covered[j]
}
}
}
effort_table <- as.data.frame(effort_table)
colnames(effort_table) <- un.date
rownames(effort_table) <- seq(1,length(grid@polygons))
write.csv(effort_table,paste("effort_table_polygons_",track_name,".csv",sep=""))
} else {
write.csv(track_name,paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/error/error_",track_name,".csv",sep=""))
}
}
library(plyr)
library(readr)
library(tidyverse)
library(rqdatatable)
library(dplyr)
library(stringr)
setwd(paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,sep=""))
mypath <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/effort",sep="")
filenames <- list.files(path = mypath, full.names = TRUE)
myfiles <- lapply(filenames, read.csv)
myfiles <- rapply(myfiles,function(x) ifelse(is.na(x),0,x), how = "replace")
mydata4 <- Reduce(function(dtf1, dtf2) full_join(dtf1, dtf2,
by = intersect(names(dtf1),names(dtf2))),myfiles)
mydata4[is.na(mydata4)] <- 0
mydata5 <- aggregate(. ~ X, FUN = sum, mydata4)
rownames(mydata5) <- mydata5$X
mydata5$X <- NULL
mydata5$NA. <- NULL
mydata5 <- mydata5[ , order(names(mydata5))]
cols.nam <- colnames(mydata5)
cols.nam <- str_sub(cols.nam, 2, 11)
length(unique(cols.nam))
colnames(mydata5) <- cols.nam
write.csv(mydata5,paste("effort_",year,".csv",sep=""))
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
year <- "2019"
Sys.setenv(TZ='Asia/Ho_Chi_Minh')
Sys.timezone() ## Check. should now say 'Asia/Ho_Chi_Minh'
time.zone = "Asia/Ho_Chi_Minh" ##in case this is ever in question!
# read in paths
setwd("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART")
source("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Modified_SMART_data_processing/functions/Initial_tracklog_processing.R")
#Identify folder where tracklogs are stored.
wd.gps <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/GPX",sep="")
###########################################
# extract  spatial point data frames, one for each file, and store as a list
AllTracks <- ReadgpxTracks (wd.in = wd.gps, include.subdirs = TRUE)
##LIST AND REMOVE FROM AllTracks FILES WHICH COULDN'T BE READ.
unreadable <- names(which(sapply(AllTracks,is.null)))
AllTracks <- AllTracks[which(!names(AllTracks) %in% unreadable)]
empty <- names(which(sapply(AllTracks,function(x){nrow(x@data)==0})))
# there are no empty ones (which aren't unreadable) so next line does nothing
AllTracks <- AllTracks[which(!names(AllTracks) %in% empty)]
#grid <- readOGR("~/Dropbox (ScreenForBio)/Wilkinson_RESHARE/empty_grids","grid_500_m_saola_PAs")
grid <- readOGR("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/lucille_working_folder","grid")
grid<-spTransform(grid, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
#study_area <- st_read("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/GIS_data/HQNSLPAsnew.shp")
SA <- shapefile("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/GIS_data/HQNSLPAsnew.shp")
SA<-spTransform(SA, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
grid2 <- crop(grid,SA)
#plot(grid)
#plot(SA,add=TRUE)
plot(grid2)
plot(SA,add=TRUE)
grid <- grid2
setwd(paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/effort",sep=""))
library(doParallel)
registerDoParallel(cores=4)
#for (k in (length(AllTracks)/2):(length(AllTracks))) {
foreach(k=1:length(AllTracks)) %dopar% {
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
track_name <- names(AllTracks[k])
track_name <- substr(track_name,1,nchar(track_name)-4)
track_name <- gsub("/", "_", track_name)
track_name <- gsub("\\.", "_", track_name)
track_name <- gsub(" ", "_", track_name)
track_point <- AllTracks[[k]]
track_point <- spTransform(track_point, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
track_points <- crop(track_point,grid)
track_points$date <- track_points$time
if (!is.null(track_points)) {
track_points$date <- format(as.POSIXct(track_points$date,format='%Y/%m/%d %H:%M:%S'),format='%Y/%m/%d')
track_points$date <- as.character(track_points$date)
un.date <- unique(track_points$date)
effort <- grid
effort@data$length <- 0
effort@data$percent_covered <- 0
effort_table <- array(NA,c(length(grid@polygons),length(un.date)))
for (i in 1:length(un.date)) {
#subset to one day
tmp <- subset(track_points, (date == un.date[i]))
#order points by time
tmp2 <- tmp[order(tmp$time),]
#turn points into line
#test2 <- points_to_line(tmp2)
#points_to_line is not working...not sure why
un.coords <- unique(tmp2@coords)
if (dim(un.coords)[1] >1) {
track_lines <- coords2Lines(tmp2@coords, ID=un.date[i])
proj4string(track_lines) <- "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
b_track_lines <- gBuffer(track_lines, width=20)
#assign projection
#proj4string(track_lines) <- "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
gI <- gIntersection(grid,b_track_lines, byid=c(TRUE, TRUE))
for (j in 1:length(grid@polygons)) {
print(j)
#take first grid cell
tmp4 <- grid[j,]
#make new extent for lines for the day in question
ext.tmp <- extent(min(tmp@coords[,1]),
max(tmp@coords[,1]),
min(tmp@coords[,2]),
max(tmp@coords[,2]))
#check if there was any activity in the current grid cell
#inter <- intersect(ext.tmp, extent(tmp4))
inter <- gIntersects(tmp4,gI, byid=TRUE)
#if there was effort figure out the distance covered
if (any(inter==TRUE)) {
print(j)
print("TRUE!")
#crop the line to the cell of interest
cell_poly <- crop(gI, extent(tmp4))
#calculate the length of the line or "distance covered"
tmp_distance <- area(cell_poly) #lineLength(cell_poly) # THIS WORKS FINE IF I CAN GET THE SHAPEFILE CROPPED PROPERLY
#assign this to the effort shapefile
cell_size <- area(tmp4)
effort@data$length[j] <- tmp_distance
effort@data$percent_covered[j] <- tmp_distance/cell_size
#if not set effort to 0
} else {
effort@data$length[j] <- 0
effort@data$percent_covered[j] <- 0
}
effort_table[j,i] <- effort@data$percent_covered[j]
}
}
}
effort_table <- as.data.frame(effort_table)
colnames(effort_table) <- un.date
rownames(effort_table) <- seq(1,length(grid@polygons))
write.csv(effort_table,paste("effort_table_polygons_",track_name,".csv",sep=""))
} else {
write.csv(track_name,paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/error/error_",track_name,".csv",sep=""))
}
}
library(plyr)
library(readr)
library(tidyverse)
library(rqdatatable)
library(dplyr)
library(stringr)
setwd(paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,sep=""))
mypath <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/effort",sep="")
filenames <- list.files(path = mypath, full.names = TRUE)
myfiles <- lapply(filenames, read.csv)
myfiles <- rapply(myfiles,function(x) ifelse(is.na(x),0,x), how = "replace")
mydata4 <- Reduce(function(dtf1, dtf2) full_join(dtf1, dtf2,
by = intersect(names(dtf1),names(dtf2))),myfiles)
mydata4[is.na(mydata4)] <- 0
mydata5 <- aggregate(. ~ X, FUN = sum, mydata4)
rownames(mydata5) <- mydata5$X
mydata5$X <- NULL
mydata5$NA. <- NULL
mydata5 <- mydata5[ , order(names(mydata5))]
cols.nam <- colnames(mydata5)
cols.nam <- str_sub(cols.nam, 2, 11)
length(unique(cols.nam))
colnames(mydata5) <- cols.nam
write.csv(mydata5,paste("effort_",year,".csv",sep=""))
