#b_roads <- gBuffer(roads, width=20)
library(RColorBrewer)
my.palette <- brewer.pal(n = 7, name = "OrRd")
bluecols <- brewer.pal(9, 'Blues')
pie(rep(1,9), col = bluecols)
newcol <- colorRampPalette(my.palette)
ncols <- 100
my.palette2 <- newcol(ncols)#apply the function to get 100 colours
pie(rep(1, ncols), col = bluecols2, border = NA, labels = NA)
require("rgdal") # requires sp, will use proj.4 if installed
require("maptools")
require("ggplot2")
require("plyr")
library(viridis)
grid2013 <- grid2
grid2013$effort<-rowSums(effort2013)
test <- fortify(grid2013, region="id")
grid2013.df = join(test, grid2013@data, by="id")
myPalette <- colorRampPalette(rev(brewer.pal(11, "Spectral")))
grid2013.df$effort[grid2013.df$effort>1000000] <- 1000000
p <- ggplot(grid2013.df) +
aes(long,lat,group=group,fill=effort) +
geom_polygon() +
geom_path(color="black") +
coord_equal() +
scale_fill_gradientn("Effort \n(m^2 covered)",
colours = my.palette2,
limits = c(0,1000000),
breaks=c(0,250000,500000,750000,1000000),
labels=c("0","250000","500000","750000",">1000000")) +
theme_minimal() +
xlab("latitude") +
ylab("longtitude") +
theme(axis.title=element_text(size=24),
axis.text=element_text(size=20),
legend.title=element_text(size=24),
legend.text=element_text(size=20))
#scale_fill_gradient(low = "yellow", high="red", limits = c(0,1000000))
#scale_fill_gradient(palette="YlOrRd",limits = c(0,1000000))
#  scale_fill_continuous("terrain",type = "gradient",limits = c(0,1000000))
#  scale_fill_viridis(option="B", limits = c(0,1000000))
png('effort_2013.png', width = 15, height = 10, units = 'in', res = 300)
print(p)
dev.off()
grid2014 <- grid2
grid2014$effort<-rowSums(effort2014)
test <- fortify(grid2014, region="id")
grid2014.df = join(test, grid2014@data, by="id")
grid2014.df$effort[grid2014.df$effort>1000000] <- 1000000
p <- ggplot(grid2014.df) +
aes(long,lat,group=group,fill=effort) +
geom_polygon()  +
geom_path(color="black") +
coord_equal() +
scale_fill_gradientn("Effort \n(m^2 covered)",
colours = my.palette2,
limits = c(0,1000000),
breaks=c(0,250000,500000,750000,1000000),
labels=c("0","250000","500000","750000",">1000000")) +
theme_minimal() +
xlab("latitude") +
ylab("longtitude") +
theme(axis.title=element_text(size=24),
axis.text=element_text(size=20),
legend.title=element_text(size=24),
legend.text=element_text(size=20))
png('effort_2014.png', width = 15, height = 10, units = 'in', res = 300)
print(p)
dev.off()
grid2015 <- grid2
grid2015$effort<-rowSums(effort2015)
test <- fortify(grid2015, region="id")
grid2015.df = join(test, grid2015@data, by="id")
grid2015.df$effort[grid2015.df$effort>1000000] <- 1000000
p <- ggplot(grid2015.df) +
aes(long,lat,group=group,fill=effort) +
geom_polygon() +
geom_path(color="black") +
coord_equal() +
scale_fill_gradientn("Effort \n(m^2 covered)",
colours = my.palette2,
limits = c(0,1000000),
breaks=c(0,250000,500000,750000,1000000),
labels=c("0","250000","500000","750000",">1000000")) +
theme_minimal() +
xlab("latitude") +
ylab("longtitude") +
theme(axis.title=element_text(size=24),
axis.text=element_text(size=20),
legend.title=element_text(size=24),
legend.text=element_text(size=20))
png('effort_2015.png', width = 15, height = 10, units = 'in', res = 300)
print(p)
dev.off()
grid2016 <- grid2
grid2016$effort<-rowSums(effort2016)
test <- fortify(grid2016, region="id")
grid2016.df = join(test, grid2016@data, by="id")
grid2016.df$effort[grid2016.df$effort>1000000] <- 1000000
p <- ggplot(grid2016.df) +
aes(long,lat,group=group,fill=effort) +
geom_polygon() +
geom_path(color="black") +
coord_equal() +
scale_fill_gradientn("Effort \n(m^2 covered)",
colours = my.palette2,
limits = c(0,1000000),
breaks=c(0,250000,500000,750000,1000000),
labels=c("0","250000","500000","750000",">1000000")) +
theme_minimal() +
xlab("latitude") +
ylab("longtitude") +
theme(axis.title=element_text(size=24),
axis.text=element_text(size=20),
legend.title=element_text(size=24),
legend.text=element_text(size=20))
png('effort_2016.png', width = 15, height = 10, units = 'in', res = 300)
print(p)
dev.off()
grid2017 <- grid2
grid2017$effort<-rowSums(effort2017)
test <- fortify(grid2017, region="id")
grid2017.df = join(test, grid2017@data, by="id")
grid2017.df$effort[grid2017.df$effort>1000000] <- 1000000
p <- ggplot(grid2017.df) +
aes(long,lat,group=group,fill=effort) +
geom_polygon() +
geom_path(color="black") +
coord_equal() +
scale_fill_gradientn("Effort \n(m^2 covered)",
colours = my.palette2,
limits = c(0,1000000),
breaks=c(0,250000,500000,750000,1000000),
labels=c("0","250000","500000","750000",">1000000")) +
theme_minimal() +
xlab("latitude") +
ylab("longtitude") +
theme(axis.title=element_text(size=24),
axis.text=element_text(size=20),
legend.title=element_text(size=24),
legend.text=element_text(size=20))
png('effort_2017.png', width = 15, height = 10, units = 'in', res = 300)
print(p)
dev.off()
grid2018 <- grid2
grid2018$effort<-rowSums(effort2018)
test <- fortify(grid2018, region="id")
grid2018.df = join(test, grid2018@data, by="id")
grid2018.df$effort[grid2018.df$effort>1000000] <- 1000000
p <- ggplot(grid2018.df) +
aes(long,lat,group=group,fill=effort) +
geom_polygon() +
geom_path(color="black") +
coord_equal() +
scale_fill_gradientn("Effort \n(m^2 covered)",
colours = my.palette2,
limits = c(0,1000000),
breaks=c(0,250000,500000,750000,1000000),
labels=c("0","250000","500000","750000",">1000000"))  +
theme_minimal() +
xlab("latitude") +
ylab("longtitude") +
theme(axis.title=element_text(size=24),
axis.text=element_text(size=20),
legend.title=element_text(size=24),
legend.text=element_text(size=20))
png('effort_2018.png', width = 15, height = 10, units = 'in', res = 300)
print(p)
dev.off()
grid2019 <- grid2
grid2019$effort<-rowSums(effort2019)
test <- fortify(grid2019, region="id")
grid2019.df = join(test, grid2019@data, by="id")
grid2019.df$effort[grid2019.df$effort>1000000] <- 1000000
p <- ggplot(grid2019.df) +
aes(long,lat,group=group,fill=effort) +
geom_polygon() +
geom_path(color="black") +
coord_equal() +
scale_fill_gradientn("Effort \n(m^2 covered)",
colours = my.palette2,
limits = c(0,1000000),
breaks=c(0,250000,500000,750000,1000000),
labels=c("0","250000","500000","750000",">1000000")) +
theme_minimal() +
xlab("latitude") +
ylab("longtitude") +
theme(axis.title=element_text(size=24),
axis.text=element_text(size=20),
legend.title=element_text(size=24),
legend.text=element_text(size=20))
png('effort_2019.png', width = 15, height = 10, units = 'in', res = 300)
print(p)
dev.off()
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
year <- "2013"
Sys.setenv(TZ='Asia/Ho_Chi_Minh')
Sys.timezone() ## Check. should now say 'Asia/Ho_Chi_Minh'
time.zone = "Asia/Ho_Chi_Minh" ##in case this is ever in question!
# read in paths
setwd("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART")
source("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Modified_SMART_data_processing/functions/Initial_tracklog_processing.R")
#Identify folder where tracklogs are stored.
wd.gps <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/GPX",sep="")
###########################################
# extract  spatial point data frames, one for each file, and store as a list
AllTracks <- ReadgpxTracks (wd.in = wd.gps, include.subdirs = TRUE)
AllTracks <- ReadmifTracks (wd.in = wd.gps, include.subdirs = TRUE)
##LIST AND REMOVE FROM AllTracks FILES WHICH COULDN'T BE READ.
unreadable <- names(which(sapply(AllTracks,is.null)))
AllTracks <- AllTracks[which(!names(AllTracks) %in% unreadable)]
empty <- names(which(sapply(AllTracks,function(x){nrow(x@data)==0})))
# there are no empty ones (which aren't unreadable) so next line does nothing
AllTracks <- AllTracks[which(!names(AllTracks) %in% empty)]
#grid <- readOGR("~/Dropbox (ScreenForBio)/Wilkinson_RESHARE/empty_grids","grid_500_m_saola_PAs")
grid <- readOGR("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/lucille_working_folder","grid")
grid<-spTransform(grid, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
#study_area <- st_read("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/GIS_data/HQNSLPAsnew.shp")
SA <- shapefile("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/GIS_data/HQNSLPAsnew.shp")
SA<-spTransform(SA, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
grid2 <- crop(grid,SA)
grid <- grid2
roads <- readOGR("~/Dropbox (ScreenForBio)/Wilkinson_RESHARE/My_GIS_data","roadsREVISED")
roads<-spTransform(roads, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
b_roads <- gBuffer(roads, width=20)
png('study_area_grid.png', width = 15, height = 10, units = 'in', res = 300)
plot(grid2,border="grey")
plot(SA,add=TRUE)
plot(b_roads,add=TRUE,col="red",border="red")
dev.off()
setwd(paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/effort",sep=""))
library(doParallel)
registerDoParallel(cores=4)
#for (k in (length(AllTracks)/2):(length(AllTracks))) {
foreach(k=1:length(AllTracks)) %dopar% {
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
track_name <- names(AllTracks[k])
track_name <- substr(track_name,1,nchar(track_name)-4)
track_name <- gsub("/", "_", track_name)
track_name <- gsub("\\.", "_", track_name)
track_name <- gsub(" ", "_", track_name)
track_point <- AllTracks[[k]]
track_point <- spTransform(track_point, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
track_points <- crop(track_point,grid)
track_points$date <- track_points$time
#gI <- area(gIntersection(b_track_lines,b_roads, byid=c(TRUE, TRUE)))
if (!is.null(track_points)) {
track_points$date <- format(as.POSIXct(track_points$date,format='%Y/%m/%d %H:%M:%S'),format='%Y/%m/%d')
track_points$date <- as.character(track_points$date)
un.date <- unique(track_points$date)
effort <- grid
effort@data$area <- 0
effort@data$percent_covered <- 0
effort_table <- array(NA,c(length(grid@polygons),length(un.date)))
for (i in 1:length(un.date)) {
#subset to one day
tmp <- subset(track_points, (date == un.date[i]))
#order points by time
tmp2 <- tmp[order(tmp$time),]
#turn points into line
#test2 <- points_to_line(tmp2)
#points_to_line is not working...not sure why
un.coords <- unique(tmp2@coords)
if (dim(un.coords)[1] >1) {
track_lines <- coords2Lines(tmp2@coords, ID=un.date[i])
proj4string(track_lines) <- "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
b_track_lines <- gBuffer(track_lines, width=20)
#assign projection
#proj4string(track_lines) <- "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
gI <- gIntersection(grid,b_track_lines, byid=c(TRUE, TRUE))
for (j in 1:length(grid@polygons)) {
print(j)
#take first grid cell
tmp4 <- grid[j,]
#make new extent for lines for the day in question
ext.tmp <- extent(min(tmp@coords[,1]),
max(tmp@coords[,1]),
min(tmp@coords[,2]),
max(tmp@coords[,2]))
#check if there was any activity in the current grid cell
#inter <- intersect(ext.tmp, extent(tmp4))
inter <- gIntersects(tmp4,gI, byid=TRUE)
#if there was effort figure out the distance covered
if (any(inter==TRUE)) {
print(j)
print("TRUE!")
#crop the line to the cell of interest
cell_poly <- crop(gI, extent(tmp4))
#calculate the length of the line or "distance covered"
cell_road <- crop(b_roads,extent(tmp4))
tmp_area <- area(cell_poly) #lineLength(cell_poly) # THIS WORKS FINE IF I CAN GET THE SHAPEFILE CROPPED PROPERLY
#assign this to the effort shapefile
cell_size <- area(tmp4)
if (!is.null(cell_road)) {
effort@data$area[j] <- tmp_area - area(gIntersection(gI,cell_road))
effort@data$percent_covered[j] <- effort@data$area[j]/cell_size
} else {
effort@data$area[j] <- tmp_area
effort@data$percent_covered[j] <- effort@data$area[j]/cell_size
}
#if not set effort to 0
} else {
effort@data$area[j] <- 0
effort@data$percent_covered[j] <- 0
}
effort_table[j,i] <- effort@data$percent_covered[j]
}
}
}
effort_table <- as.data.frame(effort_table)
colnames(effort_table) <- un.date
rownames(effort_table) <- seq(1,length(grid@polygons))
write.csv(effort_table,paste("effort_table_polygons_",track_name,".csv",sep=""))
} else {
write.csv(track_name,paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/error/error_",track_name,".csv",sep=""))
}
}
library(plyr)
library(readr)
library(tidyverse)
library(rqdatatable)
library(dplyr)
library(stringr)
setwd(paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,sep=""))
mypath <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/effort",sep="")
filenames <- list.files(path = mypath, full.names = TRUE)
myfiles <- lapply(filenames, read.csv)
myfiles <- rapply(myfiles,function(x) ifelse(is.na(x),0,x), how = "replace")
mydata4 <- Reduce(function(dtf1, dtf2) full_join(dtf1, dtf2,
by = intersect(names(dtf1),names(dtf2))),myfiles)
mydata4[is.na(mydata4)] <- 0
mydata5 <- aggregate(. ~ X, FUN = sum, mydata4)
rownames(mydata5) <- mydata5$X
mydata5$X <- NULL
mydata5$NA. <- NULL
mydata5 <- mydata5[ , order(names(mydata5))]
cols.nam <- colnames(mydata5)
cols.nam <- str_sub(cols.nam, 2, 11)
length(unique(cols.nam))
colnames(mydata5) <- cols.nam
write.csv(mydata5,paste("effort_",year,".csv",sep=""))
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
year <- "2014"
Sys.setenv(TZ='Asia/Ho_Chi_Minh')
Sys.timezone() ## Check. should now say 'Asia/Ho_Chi_Minh'
time.zone = "Asia/Ho_Chi_Minh" ##in case this is ever in question!
# read in paths
setwd("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART")
source("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Modified_SMART_data_processing/functions/Initial_tracklog_processing.R")
#Identify folder where tracklogs are stored.
wd.gps <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/GPX",sep="")
###########################################
# extract  spatial point data frames, one for each file, and store as a list
AllTracks <- ReadgpxTracks (wd.in = wd.gps, include.subdirs = TRUE)
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
year <- "2014"
Sys.setenv(TZ='Asia/Ho_Chi_Minh')
Sys.timezone() ## Check. should now say 'Asia/Ho_Chi_Minh'
time.zone = "Asia/Ho_Chi_Minh" ##in case this is ever in question!
# read in paths
setwd("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART")
source("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Modified_SMART_data_processing/functions/Initial_tracklog_processing.R")
#Identify folder where tracklogs are stored.
wd.gps <- paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/GPX",sep="")
###########################################
# extract  spatial point data frames, one for each file, and store as a list
AllTracks <- ReadgpxTracks (wd.in = wd.gps, include.subdirs = TRUE)
AllTracks <- ReadmifTracks (wd.in = wd.gps, include.subdirs = TRUE)
##LIST AND REMOVE FROM AllTracks FILES WHICH COULDN'T BE READ.
unreadable <- names(which(sapply(AllTracks,is.null)))
AllTracks <- AllTracks[which(!names(AllTracks) %in% unreadable)]
empty <- names(which(sapply(AllTracks,function(x){nrow(x@data)==0})))
# there are no empty ones (which aren't unreadable) so next line does nothing
AllTracks <- AllTracks[which(!names(AllTracks) %in% empty)]
#grid <- readOGR("~/Dropbox (ScreenForBio)/Wilkinson_RESHARE/empty_grids","grid_500_m_saola_PAs")
grid <- readOGR("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/lucille_working_folder","grid")
grid<-spTransform(grid, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
#study_area <- st_read("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/GIS_data/HQNSLPAsnew.shp")
SA <- shapefile("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/GIS_data/HQNSLPAsnew.shp")
SA<-spTransform(SA, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
grid2 <- crop(grid,SA)
grid <- grid2
roads <- readOGR("~/Dropbox (ScreenForBio)/Wilkinson_RESHARE/My_GIS_data","roadsREVISED")
roads<-spTransform(roads, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
b_roads <- gBuffer(roads, width=20)
png('study_area_grid.png', width = 15, height = 10, units = 'in', res = 300)
plot(grid2,border="grey")
plot(SA,add=TRUE)
plot(b_roads,add=TRUE,col="red",border="red")
dev.off()
setwd(paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/effort",sep=""))
library(doParallel)
registerDoParallel(cores=4)
#for (k in (length(AllTracks)/2):(length(AllTracks))) {
foreach(k=1:length(AllTracks)) %dopar% {
library(sf)
library(raster)
library(SDraw)
library(mapview)
library(sp)
library(rgeos)
library(rgdal)
library(foreach)
track_name <- names(AllTracks[k])
track_name <- substr(track_name,1,nchar(track_name)-4)
track_name <- gsub("/", "_", track_name)
track_name <- gsub("\\.", "_", track_name)
track_name <- gsub(" ", "_", track_name)
track_point <- AllTracks[[k]]
track_point <- spTransform(track_point, CRS("+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"))
track_points <- crop(track_point,grid)
track_points$date <- track_points$time
#gI <- area(gIntersection(b_track_lines,b_roads, byid=c(TRUE, TRUE)))
if (!is.null(track_points)) {
track_points$date <- format(as.POSIXct(track_points$date,format='%Y/%m/%d %H:%M:%S'),format='%Y/%m/%d')
track_points$date <- as.character(track_points$date)
un.date <- unique(track_points$date)
effort <- grid
effort@data$area <- 0
effort@data$percent_covered <- 0
effort_table <- array(NA,c(length(grid@polygons),length(un.date)))
for (i in 1:length(un.date)) {
#subset to one day
tmp <- subset(track_points, (date == un.date[i]))
#order points by time
tmp2 <- tmp[order(tmp$time),]
#turn points into line
#test2 <- points_to_line(tmp2)
#points_to_line is not working...not sure why
un.coords <- unique(tmp2@coords)
if (dim(un.coords)[1] >1) {
track_lines <- coords2Lines(tmp2@coords, ID=un.date[i])
proj4string(track_lines) <- "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
b_track_lines <- gBuffer(track_lines, width=20)
#assign projection
#proj4string(track_lines) <- "+proj=utm +zone=48 +datum=WGS84 +units=m +no_defs +ellps=WGS84 +towgs84=0,0,0"
gI <- gIntersection(grid,b_track_lines, byid=c(TRUE, TRUE))
for (j in 1:length(grid@polygons)) {
print(j)
#take first grid cell
tmp4 <- grid[j,]
#make new extent for lines for the day in question
ext.tmp <- extent(min(tmp@coords[,1]),
max(tmp@coords[,1]),
min(tmp@coords[,2]),
max(tmp@coords[,2]))
#check if there was any activity in the current grid cell
#inter <- intersect(ext.tmp, extent(tmp4))
inter <- gIntersects(tmp4,gI, byid=TRUE)
#if there was effort figure out the distance covered
if (any(inter==TRUE)) {
print(j)
print("TRUE!")
#crop the line to the cell of interest
cell_poly <- crop(gI, extent(tmp4))
#calculate the length of the line or "distance covered"
cell_road <- crop(b_roads,extent(tmp4))
tmp_area <- area(cell_poly) #lineLength(cell_poly) # THIS WORKS FINE IF I CAN GET THE SHAPEFILE CROPPED PROPERLY
#assign this to the effort shapefile
cell_size <- area(tmp4)
if (!is.null(cell_road)) {
effort@data$area[j] <- tmp_area - area(gIntersection(gI,cell_road))
effort@data$percent_covered[j] <- effort@data$area[j]/cell_size
} else {
effort@data$area[j] <- tmp_area
effort@data$percent_covered[j] <- effort@data$area[j]/cell_size
}
#if not set effort to 0
} else {
effort@data$area[j] <- 0
effort@data$percent_covered[j] <- 0
}
effort_table[j,i] <- effort@data$percent_covered[j]
}
}
}
effort_table <- as.data.frame(effort_table)
colnames(effort_table) <- un.date
rownames(effort_table) <- seq(1,length(grid@polygons))
write.csv(effort_table,paste("effort_table_polygons_",track_name,".csv",sep=""))
} else {
write.csv(track_name,paste("~/Dropbox (ScreenForBio)/WWF Vietnam SMART data/Vietnam/Tracklog 2011 - 2019/SMART/",year,"/error/error_",track_name,".csv",sep=""))
}
}
