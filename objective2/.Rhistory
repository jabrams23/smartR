include=FALSE, id=FALSE)
}
if(max(transition_mat[potential_cells],na.rm=TRUE)==0) {
potential_cells <- sample(x = adjacent(cost_layer, cell, directions=8, pairs=FALSE, target=NULL, sorted=FALSE,
include=FALSE, id=FALSE),
size=1)
}
potential_cells <- potential_cells[!is.na(transition_mat[potential_cells])]
if(length(potential_cells)==1) {
next_cell <- potential_cells
} else {
next_cell <- sample(x=potential_cells,
size=1,
prob=transition_mat[potential_cells])
}
#next_cell <- potential_cells[which.min(cost_layer[potential_cells])]
return(next_cell)
}
generate_route <- function(start_cell,trans_mat,cost_layer,reward_layer,t){
library(reshape2)
library(raster)
total_cost <- 0
total_reward <- 0
current_cell <- start_cell
cells_covered <- start_cell
while (total_cost < t){
previous_cell <- current_cell
current_cell <- select_next_cell(cost_layer,previous_cell,trans_mat,cells_covered)
total_reward <- total_reward + calculate_reward(reward_input=reward_layer,
cell=current_cell)
cost <- calculate_cost(cost_layer,previous_cell,current_cell)
total_cost <- total_cost + cost #cost_layer[current_cell]
cells_covered <- cbind(cells_covered,current_cell)
}
tmp_return <- list(cells_covered,total_reward)
return(tmp_return)
#return(total_reward)
}
ce <- function(numb,mat,cost,reward,start,total_time) {
#setup parallel backend to use many processors
cores=detectCores()
cl <- makeCluster(cores[1]-2) #not to overload your computer
registerDoParallel(cl)
rew <- rep(0,numb)
route <- vector(mode = "list", length = numb)
#for (i in 1:numb)
#  print(i)
#  tmp <- generate_route(start_cell=1,
#                        trans_mat=mat,
#                        cost_layer=cost,
#                        reward_layer=reward,
#                        t=time)
#  rew[i]<-tmp[[2]]
#  route[[i]]<-as.vector(tmp[[1]])
#}
tmp_test <- foreach(i = 1:numb, .export=c("calculate_cost","calculate_reward", "generate_route","select_next_cell")) %dopar% {
print(i)
tmp <- generate_route(start_cell=start,
trans_mat=mat,
cost_layer=cost,
reward_layer=reward,
t=total_time)
}
stopCluster(cl)
gc()
for (k in 1:numb) {
rew[k]<-as.vector(tmp_test[[k]][2])
route[k]<-as.vector(tmp_test[[k]][1])
}
ten_percent <- 0.1 * numb
rew <- unlist(rew)
tmp2 <- sort(rew, decreasing = TRUE)
tmp_10 <- tmp2[ten_percent]
selected_routes <- route[which(rew>=tmp_10)]
return(selected_routes)
}
update_transition <- function(cost_matrix,tran_mat,select,numbr){
tmp1 <- unlist(select)
tmp3 <- as.data.frame(table(tmp1))
tmp3$tmp1 <- as.numeric(as.character(tmp3$tmp1))
#tran_mat@data@values[!is.na(tran_mat@data@values)] <- 0
tran_mat@data@values[tmp3$tmp1] <- as.vector(tmp3$Freq)/(numbr*0.1)
tran_mat@data@values <- ifelse(tran_mat@data@values>1, 1, tran_mat@data@values)
return(tran_mat)
}
range01 <- function(x){(x-min(x,na.rm=TRUE))/(max(x,na.rm=TRUE)-min(x,na.rm=TRUE))}
########## TESTING
reward_layer <- hotspots
cost_layer <- cost
#values(cost_layer) <- range01(values(cost_layer))
transition_mat <- cost_layer
values(transition_mat) <- 0.5
transition_mat <- mask(transition_mat,cost_layer)
numb<-100
reps<-10
for (i in 1:reps) {
#transition_mat <- (0.5*(1-cost_layer))+(0.5*transition_mat)
test <- ce(numb,transition_mat,cost_layer,reward_layer,start=25000,total_time=10000)
transition_mat <- update_transition(cost_layer,transition_mat,test,numb)
plot(transition_mat)
}
#numb=numb;mat=transition_mat;cost=cost_layer;reward=reward_layer;start=25000;time=100
# So the general idea here follows the logic from the paper I shared with you.
# We first select a starting point
# Then we select a random neighbor cell to go to from t=1 until t = whatever limit we set
# we select the random cell according to which has the highest transition probability
# calculate the patrol reward
# then we do this 1000 times (or however many) according to the algorithm above
# keep the top 10% of these routes
# use them to update the transition matrix
# then we repeat that until we reach convergence
library(reshape2)
library(raster)
library(foreach)
library(doParallel)
##### FUNCTIONS
calculate_reward <- function(reward_input, cell){
reward <- reward_input[cell]
return(reward)
}
calculate_cost <- function(costlayer,prev,cur){
tmp_cost <- abs(costlayer[prev]-costlayer[cur])
return(tmp_cost)
}
select_next_cell <- function(cost_layer,cell, transition_mat, covered){
potential_cells <- adjacent(cost_layer, cell, directions=8, pairs=FALSE, target=NULL, sorted=FALSE,
include=FALSE, id=FALSE)
potential_cells <- potential_cells[!potential_cells %in% covered]
potential_cells <- potential_cells[!is.na(transition_mat[potential_cells])]
if(length(potential_cells)==0) {
potential_cells <- adjacent(cost_layer, cell, directions=8, pairs=FALSE, target=NULL, sorted=FALSE,
include=FALSE, id=FALSE)
}
if(max(transition_mat[potential_cells],na.rm=TRUE)==0) {
potential_cells <- sample(x = adjacent(cost_layer, cell, directions=8, pairs=FALSE, target=NULL, sorted=FALSE,
include=FALSE, id=FALSE),
size=1)
}
potential_cells <- potential_cells[!is.na(transition_mat[potential_cells])]
if(length(potential_cells)==1) {
next_cell <- potential_cells
} else {
next_cell <- sample(x=potential_cells,
size=1,
prob=transition_mat[potential_cells])
}
#next_cell <- potential_cells[which.min(cost_layer[potential_cells])]
return(next_cell)
}
generate_route <- function(start_cell,trans_mat,cost_layer,reward_layer,t){
library(reshape2)
library(raster)
total_cost <- 0
total_reward <- 0
current_cell <- start_cell
cells_covered <- start_cell
while (total_cost < t){
previous_cell <- current_cell
current_cell <- select_next_cell(cost_layer,previous_cell,trans_mat,cells_covered)
total_reward <- total_reward + calculate_reward(reward_input=reward_layer,
cell=current_cell)
cost <- calculate_cost(cost_layer,previous_cell,current_cell)
total_cost <- total_cost + cost #cost_layer[current_cell]
cells_covered <- cbind(cells_covered,current_cell)
}
tmp_return <- list(cells_covered,total_reward)
return(tmp_return)
#return(total_reward)
}
ce <- function(numb,mat,cost,reward,start,total_time) {
#setup parallel backend to use many processors
cores=detectCores()
cl <- makeCluster(cores[1]-2) #not to overload your computer
registerDoParallel(cl)
rew <- rep(0,numb)
route <- vector(mode = "list", length = numb)
#for (i in 1:numb)
#  print(i)
#  tmp <- generate_route(start_cell=1,
#                        trans_mat=mat,
#                        cost_layer=cost,
#                        reward_layer=reward,
#                        t=time)
#  rew[i]<-tmp[[2]]
#  route[[i]]<-as.vector(tmp[[1]])
#}
tmp_test <- foreach(i = 1:numb, .export=c("calculate_cost","calculate_reward", "generate_route","select_next_cell")) %dopar% {
print(i)
tmp <- generate_route(start_cell=start,
trans_mat=mat,
cost_layer=cost,
reward_layer=reward,
t=total_time)
}
stopCluster(cl)
gc()
for (k in 1:numb) {
rew[k]<-as.vector(tmp_test[[k]][2])
route[k]<-as.vector(tmp_test[[k]][1])
}
ten_percent <- 0.1 * numb
rew <- unlist(rew)
tmp2 <- sort(rew, decreasing = TRUE)
tmp_10 <- tmp2[ten_percent]
selected_routes <- route[which(rew>=tmp_10)]
return(selected_routes)
}
update_transition <- function(cost_matrix,tran_mat,select,numbr){
tmp1 <- unlist(select)
tmp3 <- as.data.frame(table(tmp1))
tmp3$tmp1 <- as.numeric(as.character(tmp3$tmp1))
#tran_mat@data@values[!is.na(tran_mat@data@values)] <- 0
tran_mat@data@values[tmp3$tmp1] <- as.vector(tmp3$Freq)/(numbr*0.1)
tran_mat@data@values <- ifelse(tran_mat@data@values>1, 1, tran_mat@data@values)
return(tran_mat)
}
range01 <- function(x){(x-min(x,na.rm=TRUE))/(max(x,na.rm=TRUE)-min(x,na.rm=TRUE))}
########## TESTING
reward_layer <- hotspots
cost_layer <- cost
#values(cost_layer) <- range01(values(cost_layer))
transition_mat <- cost_layer
values(transition_mat) <- 0.5
transition_mat <- mask(transition_mat,cost_layer)
numb<-100
reps<-10
for (i in 1:reps) {
#transition_mat <- (0.5*(1-cost_layer))+(0.5*transition_mat)
test <- ce(numb,transition_mat,cost_layer,reward_layer,start=25000,total_time=1000)
transition_mat <- update_transition(cost_layer,transition_mat,test,numb)
plot(transition_mat)
}
#numb=numb;mat=transition_mat;cost=cost_layer;reward=reward_layer;start=25000;time=100
######################
# Code for hotspot analysis of SMART patrol data
# by Jesse F. Abrams
######################
# Load libraries
library(spdep)
library(rgdal)
library(lattice)
library(raster)
library(rgeos)
# Set working directory
setwd("~/Documents/GitHub/smartR/objective2")
# Load data
threat <- raster("~/Dropbox (ScreenForBio)/Jesse's stuff/smartpatrol/objective2/Data/cumulative_rasters/Detections_cumul_AllTraps.tif")
#threat <- flip(threat, 1)
new_extent <- extent(threat)
new_extent@xmin <- 107.4
new_extent@xmax <- 107.8
new_extent@ymin <- 15.9
new_extent@ymax <- 16.2
threat <- crop(threat,new_extent)
cost <- raster("/Users/jesse/Desktop/wwf_optim/CC_slope_roads_river_lc_elevation.tif")
cost <- resample(cost,threat)
cost <- crop(cost,new_extent)
cost <- mask(cost,threat)
neighborhoods <- readOGR(dsn="~/Dropbox (ScreenForBio)/Jesse's stuff/smartpatrol/objective2/Data/GIS_data", layer='HQNSLPAsnew', stringsAsFactors = F)
neighborhoods <- spTransform(neighborhoods, proj4string(threat))
plot(neighborhoods, col=terrain.colors(nrow(neighborhoods)))
getisgrid <- rasterToPolygons(threat)
# Create the list of neighbors
neighbors <- poly2nb(getisgrid)
weighted_neighbors <- nb2listw(neighbors, zero.policy=T)
vals <- values(threat)
vals <- vals[!is.na(vals)]
# Perform the local G analysis (Getis-Ord GI*)
getisgrid$HOTSPOT = as.vector(localG(vals, weighted_neighbors))
#hotspot <- getisgrid
#hotspot@data$Detections_cumul_AllTraps <- NULL
hotspots <- rasterize(getisgrid,threat,"HOTSPOT")
# So the general idea here follows the logic from the paper I shared with you.
# We first select a starting point
# Then we select a random neighbor cell to go to from t=1 until t = whatever limit we set
# we select the random cell according to which has the highest transition probability
# calculate the patrol reward
# then we do this 1000 times (or however many) according to the algorithm above
# keep the top 10% of these routes
# use them to update the transition matrix
# then we repeat that until we reach convergence
library(reshape2)
library(raster)
library(foreach)
library(doParallel)
##### FUNCTIONS
calculate_reward <- function(reward_input, cell){
reward <- reward_input[cell]
return(reward)
}
calculate_cost <- function(costlayer,prev,cur){
tmp_cost <- abs(costlayer[prev]-costlayer[cur])
return(tmp_cost)
}
select_next_cell <- function(cost_layer,cell, transition_mat, covered){
potential_cells <- adjacent(cost_layer, cell, directions=8, pairs=FALSE, target=NULL, sorted=FALSE,
include=FALSE, id=FALSE)
potential_cells <- potential_cells[!potential_cells %in% covered]
potential_cells <- potential_cells[!is.na(transition_mat[potential_cells])]
if(length(potential_cells)==0) {
potential_cells <- adjacent(cost_layer, cell, directions=8, pairs=FALSE, target=NULL, sorted=FALSE,
include=FALSE, id=FALSE)
}
if(max(transition_mat[potential_cells],na.rm=TRUE)==0) {
potential_cells <- sample(x = adjacent(cost_layer, cell, directions=8, pairs=FALSE, target=NULL, sorted=FALSE,
include=FALSE, id=FALSE),
size=1)
}
potential_cells <- potential_cells[!is.na(transition_mat[potential_cells])]
if(length(potential_cells)==1) {
next_cell <- potential_cells
} else {
next_cell <- sample(x=potential_cells,
size=1,
prob=transition_mat[potential_cells])
}
#next_cell <- potential_cells[which.min(cost_layer[potential_cells])]
return(next_cell)
}
generate_route <- function(start_cell,trans_mat,cost_layer,reward_layer,t){
library(reshape2)
library(raster)
total_cost <- 0
total_reward <- 0
current_cell <- start_cell
cells_covered <- start_cell
while (total_cost < t){
previous_cell <- current_cell
current_cell <- select_next_cell(cost_layer,previous_cell,trans_mat,cells_covered)
total_reward <- total_reward + calculate_reward(reward_input=reward_layer,
cell=current_cell)
cost <- calculate_cost(cost_layer,previous_cell,current_cell)
total_cost <- total_cost + cost #cost_layer[current_cell]
cells_covered <- cbind(cells_covered,current_cell)
}
tmp_return <- list(cells_covered,total_reward)
return(tmp_return)
#return(total_reward)
}
ce <- function(numb,mat,cost,reward,start,total_time) {
#setup parallel backend to use many processors
cores=detectCores()
cl <- makeCluster(cores[1]-2) #not to overload your computer
registerDoParallel(cl)
rew <- rep(0,numb)
route <- vector(mode = "list", length = numb)
#for (i in 1:numb)
#  print(i)
#  tmp <- generate_route(start_cell=1,
#                        trans_mat=mat,
#                        cost_layer=cost,
#                        reward_layer=reward,
#                        t=time)
#  rew[i]<-tmp[[2]]
#  route[[i]]<-as.vector(tmp[[1]])
#}
tmp_test <- foreach(i = 1:numb, .export=c("calculate_cost","calculate_reward", "generate_route","select_next_cell")) %dopar% {
print(i)
tmp <- generate_route(start_cell=start,
trans_mat=mat,
cost_layer=cost,
reward_layer=reward,
t=total_time)
}
stopCluster(cl)
gc()
for (k in 1:numb) {
rew[k]<-as.vector(tmp_test[[k]][2])
route[k]<-as.vector(tmp_test[[k]][1])
}
ten_percent <- 0.1 * numb
rew <- unlist(rew)
tmp2 <- sort(rew, decreasing = TRUE)
tmp_10 <- tmp2[ten_percent]
selected_routes <- route[which(rew>=tmp_10)]
return(selected_routes)
}
update_transition <- function(cost_matrix,tran_mat,select,numbr){
tmp1 <- unlist(select)
tmp3 <- as.data.frame(table(tmp1))
tmp3$tmp1 <- as.numeric(as.character(tmp3$tmp1))
#tran_mat@data@values[!is.na(tran_mat@data@values)] <- 0
tran_mat@data@values[tmp3$tmp1] <- as.vector(tmp3$Freq)/(numbr*0.1)
tran_mat@data@values <- ifelse(tran_mat@data@values>1, 1, tran_mat@data@values)
return(tran_mat)
}
range01 <- function(x){(x-min(x,na.rm=TRUE))/(max(x,na.rm=TRUE)-min(x,na.rm=TRUE))}
########## TESTING
reward_layer <- hotspots
cost_layer <- cost
#values(cost_layer) <- range01(values(cost_layer))
transition_mat <- cost_layer
values(transition_mat) <- 0.5
transition_mat <- mask(transition_mat,cost_layer)
numb<-100
reps<-10
for (i in 1:reps) {
#transition_mat <- (0.5*(1-cost_layer))+(0.5*transition_mat)
test <- ce(numb,transition_mat,cost_layer,reward_layer,start=25000,total_time=1000)
transition_mat <- update_transition(cost_layer,transition_mat,test,numb)
plot(transition_mat)
}
#numb=numb;mat=transition_mat;cost=cost_layer;reward=reward_layer;start=25000;time=100
reward_layer <- hotspots
cost_layer <- cost
#values(cost_layer) <- range01(values(cost_layer))
transition_mat <- cost_layer
values(transition_mat) <- 0.5
transition_mat <- mask(transition_mat,cost_layer)
numb<-100
reps<-10
for (i in 1:reps) {
#transition_mat <- (0.5*(1-cost_layer))+(0.5*transition_mat)
test <- ce(numb,transition_mat,cost_layer,reward_layer,start=25000,total_time=5000)
transition_mat <- update_transition(cost_layer,transition_mat,test,numb)
plot(transition_mat)
}
reward_layer <- hotspots
cost_layer <- cost
#values(cost_layer) <- range01(values(cost_layer))
transition_mat <- cost_layer
values(transition_mat) <- 0.5
transition_mat <- mask(transition_mat,cost_layer)
plot(transition_mat)
numb<-100
reps<-10
rm(test)
for (i in 1:reps) {
#transition_mat <- (0.5*(1-cost_layer))+(0.5*transition_mat)
test <- ce(numb,transition_mat,cost_layer,reward_layer,start=25000,total_time=30000)
transition_mat <- update_transition(cost_layer,transition_mat,test,numb)
plot(transition_mat)
}
reward_layer <- hotspots
cost_layer <- cost
#values(cost_layer) <- range01(values(cost_layer))
transition_mat <- cost_layer
values(transition_mat) <- 0.5
transition_mat <- mask(transition_mat,cost_layer)
numb<-100
reps<-10
for (i in 1:reps) {
#transition_mat <- (0.5*(1-cost_layer))+(0.5*transition_mat)
test <- ce(numb,transition_mat,cost_layer,reward_layer,start=25000,total_time=100000)
transition_mat <- update_transition(cost_layer,transition_mat,test,numb)
plot(transition_mat)
}
#numb=numb;mat=transition_mat;cost=cost_layer;reward=reward_layer;start=25000;time=100
reward_layer <- hotspots
cost_layer <- cost
#values(cost_layer) <- range01(values(cost_layer))
transition_mat <- cost_layer
values(transition_mat) <- 0.5
transition_mat <- mask(transition_mat,cost_layer)
numb<-100
reps<-10
for (i in 1:reps) {
#transition_mat <- (0.5*(1-cost_layer))+(0.5*transition_mat)
test <- ce(numb,transition_mat,cost_layer,reward_layer,start=25000,total_time=10000000)
transition_mat <- update_transition(cost_layer,transition_mat,test,numb)
plot(transition_mat)
}
#numb=numb;mat=transition_mat;cost=cost_layer;reward=reward_layer;start=25000;time=100
reward_layer <- hotspots
cost_layer <- cost
#values(cost_layer) <- range01(values(cost_layer))
transition_mat <- cost_layer
values(transition_mat) <- 0.5
transition_mat <- mask(transition_mat,cost_layer)
numb<-10000
reps<-100
for (i in 1:reps) {
#transition_mat <- (0.5*(1-cost_layer))+(0.5*transition_mat)
test <- ce(numb,transition_mat,cost_layer,reward_layer,start=25000,total_time=10000000)
transition_mat <- update_transition(cost_layer,transition_mat,test,numb)
plot(transition_mat)
}
#numb=numb;mat=transition_mat;cost=cost_layer;reward=reward_layer;start=25000;time=100
reward_layer <- hotspots
cost_layer <- cost
#values(cost_layer) <- range01(values(cost_layer))
transition_mat <- cost_layer
values(transition_mat) <- 0.5
transition_mat <- mask(transition_mat,cost_layer)
numb<-10000
reps<-100
for (i in 1:reps) {
#transition_mat <- (0.5*(1-cost_layer))+(0.5*transition_mat)
print(reps)
test <- ce(numb,transition_mat,cost_layer,reward_layer,start=25000,total_time=10000000)
transition_mat <- update_transition(cost_layer,transition_mat,test,numb)
plot(transition_mat)
}
#numb=numb;mat=transition_mat;cost=cost_layer;reward=reward_layer;start=25000;time=100
reward_layer <- hotspots
cost_layer <- cost
#values(cost_layer) <- range01(values(cost_layer))
transition_mat <- cost_layer
values(transition_mat) <- 0.5
transition_mat <- mask(transition_mat,cost_layer)
numb<-10000
reps<-100
for (i in 1:reps) {
#transition_mat <- (0.5*(1-cost_layer))+(0.5*transition_mat)
print(i)
test <- ce(numb,transition_mat,cost_layer,reward_layer,start=25000,total_time=10000000)
transition_mat <- update_transition(cost_layer,transition_mat,test,numb)
plot(transition_mat)
}
#numb=numb;mat=transition_mat;cost=cost_layer;reward=reward_layer;start=25000;time=100
stopCluster(cl)
gc()
